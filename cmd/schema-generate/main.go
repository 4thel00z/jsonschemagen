// The schema-generate binary reads the JSON schema files passed as arguments
// and outputs the corresponding Go structs.
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"sort"
	"strings"

	"github.com/a-h/generate"
	"github.com/a-h/generate/jsonschema"
)

var (
	o = flag.String("o", "", "The output file for the schema.")
	p = flag.String("p", "main", "The package that the structs are created in.")
	i = flag.String("i", "", "A single file path (used for backwards compatibility).")
)

func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
		flag.PrintDefaults()
		fmt.Fprintln(os.Stderr, "  paths")
		fmt.Fprintln(os.Stderr, "\tThe input JSON Schema files.")
	}

	flag.Parse()

	inputFiles := flag.Args()
	if *i != "" {
		inputFiles = append(inputFiles, *i)
	}
	if len(inputFiles) == 0 {
		fmt.Fprintln(os.Stderr, "No input JSON Schema files.")
		flag.Usage()
		os.Exit(1)
	}

	schemas := make([]*jsonschema.Schema, len(inputFiles))
	for i, file := range inputFiles {
		b, err := ioutil.ReadFile(file)
		if err != nil {
			fmt.Fprintln(os.Stderr, "Failed to read the input file with error ", err)
			return
		}

		schemas[i], err = jsonschema.Parse(string(b))
		if err != nil {
			if jsonError, ok := err.(*json.SyntaxError); ok {
				line, character, lcErr := lineAndCharacter(b, int(jsonError.Offset))
				fmt.Fprintf(os.Stderr, "Cannot parse JSON schema due to a syntax error at %s line %d, character %d: %v\n", file, line, character, jsonError.Error())
				if lcErr != nil {
					fmt.Fprintf(os.Stderr, "Couldn't find the line and character position of the error due to error %v\n", lcErr)
				}
				return
			}
			if jsonError, ok := err.(*json.UnmarshalTypeError); ok {
				line, character, lcErr := lineAndCharacter(b, int(jsonError.Offset))
				fmt.Fprintf(os.Stderr, "The JSON type '%v' cannot be converted into the Go '%v' type on struct '%s', field '%v'. See input file %s line %d, character %d\n", jsonError.Value, jsonError.Type.Name(), jsonError.Struct, jsonError.Field, file, line, character)
				if lcErr != nil {
					fmt.Fprintf(os.Stderr, "Couldn't find the line and character position of the error due to error %v\n", lcErr)
				}
				return
			}
			fmt.Fprintf(os.Stderr, "Failed to parse the input JSON schema file %s with error %v\n", file, err)
			return
		}
	}

	g := generate.New(schemas...)

	err := g.CreateTypes()
	if err != nil {
		fmt.Fprintln(os.Stderr, "Failure generating structs: ", err)
		os.Exit(1)
	}

	var w io.Writer = os.Stdout

	if *o != "" {
		w, err = os.Create(*o)

		if err != nil {
			fmt.Fprintln(os.Stderr, "Error opening output file: ", err)
			return
		}
	}

	output(w, g.Structs, g.Aliases)
}

func lineAndCharacter(bytes []byte, offset int) (line int, character int, err error) {
	lf := byte(0x0A)

	if offset > len(bytes) {
		return 0, 0, fmt.Errorf("couldn't find offset %d in %d bytes", offset, len(bytes))
	}

	// Humans tend to count from 1.
	line = 1

	for i, b := range bytes {
		if b == lf {
			line++
			character = 0
		}
		character++
		if i == offset {
			return line, character, nil
		}
	}

	return 0, 0, fmt.Errorf("couldn't find offset %d in %d bytes", offset, len(bytes))
}

func getOrderedFieldNames(m map[string]generate.Field) []string {
	keys := make([]string, len(m))
	idx := 0
	for k := range m {
		keys[idx] = k
		idx++
	}
	sort.Strings(keys)
	return keys
}

func getOrderedStructNames(m map[string]generate.Struct) []string {
	keys := make([]string, len(m))
	idx := 0
	for k := range m {
		keys[idx] = k
		idx++
	}
	sort.Strings(keys)
	return keys
}

func output(w io.Writer, structs map[string]generate.Struct, aliases map[string]generate.Field) {
	fmt.Fprintln(w, "// Code generated by schema-generate. DO NOT EDIT.")
	fmt.Fprintln(w)
	fmt.Fprintf(w, "package %v\n", *p)

	willEmitCode := false
	for _, v := range structs {
		if v.AdditionalValueType != "" {
			willEmitCode = true
		}
	}

	if willEmitCode {
		fmt.Fprintf(w, `
import (
	"fmt"
	"encoding/json"
	"bytes"
)
`)
	}

	for _, k := range getOrderedFieldNames(aliases) {
		a := aliases[k]

		fmt.Fprintln(w, "")
		fmt.Fprintf(w, "// %s\n", a.Name)
		fmt.Fprintf(w, "type %s %s\n", a.Name, a.Type)
	}

	for _, k := range getOrderedStructNames(structs) {
		s := structs[k]

		fmt.Fprintln(w, "")
		outputNameAndDescriptionComment(s.Name, s.Description, w)
		fmt.Fprintf(w, "type %s struct {\n", s.Name)

		for _, fieldKey := range getOrderedFieldNames(s.Fields) {
			f := s.Fields[fieldKey]

			// Only apply omitempty if the field is not required.
			omitempty := ",omitempty"
			if f.Required {
				omitempty = ""
			}

			if f.Comment != "" {
				fmt.Fprintf(w, "  // %s\n", f.Comment)
			}

			fmt.Fprintf(w, "  %s %s `json:\"%s%s\"`\n", f.Name, f.Type, f.JSONName, omitempty)
		}

		fmt.Fprintln(w, "}")

		if s.AdditionalValueType != "" {
			emitMarshalCode(w, s)
			emitUnmarshalCode(w, s)
		}
	}
}

func emitMarshalCode(w io.Writer, s generate.Struct) {
	fmt.Fprintf(w,
		`
func (strct *%s) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
`, s.Name)
	// Marshal all the defined fields
	for _, fieldKey := range getOrderedFieldNames(s.Fields) {
		f := s.Fields[fieldKey]
		if f.JSONName == "-" {
			continue
		}
		fmt.Fprintf(w,
			`    // Marshal the "%s" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"%s\": ")
	if tmp, err := json.Marshal(strct.%s); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
`, f.JSONName, f.JSONName, f.Name)
	}
	fmt.Fprintf(w, "    // Marshal any additional Properties\n")
	// Marshal any additional Properties
	fmt.Fprintf(w, `    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}
`)
}

func emitUnmarshalCode(w io.Writer, s generate.Struct) {
	// unmarshal code
	fmt.Fprintf(w, `
func (strct *%s) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // first parse all the defined properties
    for k, v := range jsonMap {
        switch k {
`, s.Name)
	// handle defined properties
	for _, fieldKey := range getOrderedFieldNames(s.Fields) {
		f := s.Fields[fieldKey]
		if f.JSONName == "-" {
			continue
		}
		fmt.Fprintf(w, `        case "%s":
            if err := json.Unmarshal([]byte(v), &strct.%s); err != nil {
                return err
             }
`, f.JSONName, f.Name)
	}
	// now handle additional values
	initialiser, isPrimitive := getPrimitiveInitialiser(s.AdditionalValueType)
	addressOfInitialiser := "&"
	if isPrimitive {
		addressOfInitialiser = ""
	}
	fmt.Fprintf(w, `        default:
            // an additional "%s" value
            additionalValue := %s
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]%s, 0)
            }
            strct.AdditionalProperties[k]= %sadditionalValue
`, s.AdditionalValueType, initialiser, s.AdditionalValueType, addressOfInitialiser)
	fmt.Fprintf(w, "        }\n")
	fmt.Fprintf(w, "    }\n")
	fmt.Fprintf(w, "    return nil\n")
	fmt.Fprintf(w, "}\n")
}

func getPrimitiveInitialiser(typ string) (string, bool) {
	// strip *pointer dereference symbol so we can use in declaration
	deref := strings.Replace(typ, "*", "", 1)
	switch {
	case strings.HasPrefix(deref, "int"):
		return "0", true
	case strings.HasPrefix(deref, "float"):
		return "0.0", true
	case deref == "string":
		return "\"\"", true
	}
	return deref + "{}", false
}

func outputNameAndDescriptionComment(name, description string, w io.Writer) {
	if strings.Index(description, "\n") == -1 {
		fmt.Fprintf(w, "// %s %s\n", name, description)
		return
	}

	dl := strings.Split(description, "\n")
	fmt.Fprintf(w, "// %s %s\n", name, strings.Join(dl, "\n// "))
}
